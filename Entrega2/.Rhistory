#Model expressed as an AR infinity (pi-weights)
pis=-ARMAtoMA(ar=-model$model$theta,ma=-model$model$phi,lag.max=36)
names(pis)=paste("pi",1:36)
cat("\nPi-weights (AR(inf))\n")
cat("\n--------------------\n")
print(pis[1:20])
## Add here complementary tests (use with caution!)
##---------------------------------------------------------
cat("\nNormality Tests\n")
cat("\n--------------------\n")
##Shapiro-Wilks Normality test
print(shapiro.test(resid(model)))
sw<-round(shapiro.test(resid(model))$p.value,4)
suppressMessages(require(nortest,quietly=TRUE,warn.conflicts=FALSE))
##Anderson-Darling test
print(ad.test(resid(model)))
ad<-round(ad.test(resid(model))$p.value,4)
suppressMessages(require(tseries,quietly=TRUE,warn.conflicts=FALSE))
##Jarque-Bera test
print(jarque.bera.test(resid(model)))
jb<-round(jarque.bera.test(resid(model))$p.value,4)
cat("\nHomoscedasticity Test\n")
cat("\n--------------------\n")
suppressMessages(require(lmtest,quietly=TRUE,warn.conflicts=FALSE))
##Breusch-Pagan test
obs=get(model$series)
print(bptest(resid(model)~I(obs-resid(model))))
bp<-round(bptest(resid(model)~I(obs-resid(model)))$p.value,4)
cat("\nIndependence Tests\n")
cat("\n--------------------\n")
##Durbin-Watson test
print(dwtest(resid(model)~I(1:length(resid(model)))))
dw<-dwtest(resid(model)~I(1:length(resid(model))))$p.value
##Ljung-Box test
cat("\nLjung-Box test\n")
print(t(apply(matrix(c(1:4,(1:4)*s)),1,function(el) {
te=Box.test(resid(model),type="Ljung-Box",lag=el)
c(lag=(te$parameter),statistic=te$statistic[[1]],p.value=te$p.value)})))
##************End of complementary tests******************************************
lj<-round(t(apply(matrix(c(1:4,(1:4)*s)),1,function(el) {
te=Box.test(resid(model),type="Ljung-Box",lag=el)
c(lag=(te$parameter),statistic=te$statistic[[1]],p.value=te$p.value)}))[,3],4)
################# Fi Validación ('Validation') #################################
resumen<-data.frame(Pruebas=1:18)
colnames(resumen)<-paste0("mod1B")
rownames(resumen)<-c("Shapiro-Wilks Normality p-value","Anderson-Darling p-value","Jarque-Bera p-value","Breusch-Pagan p-value","Durbin-Watson p-value",
"Ljung-Box (lag 1) p-value","Ljung-Box (lag 2) p-value","Ljung-Box (lag 3) p-value","Ljung-Box (lag4) p-value",
"Ljung-Box (lag 12) p-value","Ljung-Box (lag 24) p-value","Ljung-Box (lag 36) p-value","Ljung-Box (lag 48) p-value",
"Log Likelihood","AIC","RMSPE", "MAPE","Mean Length")
resumen[1,1]=sw[1]
resumen[2,1]=ad[1]
resumen[3,1]=jb[1]
resumen[4,1]=bp[1]
resumen[5,1]=dw[1]
resumen[6,1]=lj[1]
resumen[7,1]=lj[2]
resumen[8,1]=lj[3]
resumen[9,1]=lj[4]
resumen[10,1]=lj[5]
resumen[11,1]=lj[6]
resumen[12,1]=lj[7]
resumen[13,1]=lj[8]
resumen[14,1]=model$loglik
resumen[15,1]=model$aic
resumen[16,1]=NA
resumen[17,1]=NA
resumen[18,1]=NA
return(resumen)
}
model=mod1B         #Modelo ARIMA ajustado: en este caso ARIMA(2,1,0)(0,1,1)_12 para lnserie
validation(model)
########### Estabilitat Model (SENSE CONSTANT/Without constant!!!!) ###############
ultim = c(2018, 12)                       #Dic 2018
# Serie completa: 2009-2019
serie1 = window(serie, end = ultim + c(1, 0))
lnserie1 = log(serie1)                   #log transformed
# Series without last year obsrvations: 2009-2018
serie2 = window(serie, end = ultim)
lnserie2 = log(serie2)                   #log transformed
# Fit the model to the complete series: lnserie1
(mod1B = arima(lnserie1,order = c(2,1,0),seasonal = list(order = c(0,1,1),period = 12)))
# Fit the model to the subset series (without 2019 data): lnserie2
(mod1B2 = arima(lnserie2,order = c(2,1,0),seasonal = list(order = c(0,1,1),period = 12)))
# mod1B2 es hasta 2018. Indicamos que queremos predicción de 12 meses
pred = predict(mod1B2, n.ahead = 12)                              #outputs point predictions and corresponding standard errors:for year 2019
pr <- ts(c(tail(lnserie2, 1), pred$pred), start = ultim, freq = 12)  #point predictions
se<-ts(c(0,pred$se),start = ultim,freq = 12)                   #Standard errors for point predictions
#Prediction Intervals (back transformed to original scale using exp-function)
tl<-ts(exp(pr-1.96*se),start = ultim,freq = 12)
tu<-ts(exp(pr+1.96*se),start = ultim,freq = 12)
# Deshacemos la predicción, pues era logarítmica
pr<-ts(exp(pr), start = ultim, freq = 12)             #predictions in original scale
#Plot of the original airbcn series (thousands) and out-of-sample predictions: only time window 2015-2019 shown
ts.plot(serie,tl,tu,pr,lty = c(1,2,2,1),col = c(1,4,4,2),xlim = ultim[1]+c(-3,+2),type = "o",main = "Model ARIMA(2,1,0)(0,1,1)_{12}")
abline(v = (ultim[1]-3):(ultim[1]+2),lty = 3,col = 4)
(previs = window(cbind(tl,pr,tu,serie,error = round(serie-pr,3)),start = ultim))
obs = window(serie, start = ultim)
(mod.EQM1 = sqrt(sum(((obs-pr)/obs)^2)/12))   # Error  =  obs - pred
(mod.EAM1 = sum(abs(obs-pr)/obs)/12)   # Error Absoluto Medio
(mod.ML1 = sum(tu-tl)/12)    # cuanto más pequeño sea mejor. Sirve para comparar entre modelos.
##### Previsions a llarg termini amb el model complet ######
pred = predict(mod1B,n.ahead = 12)
pr<-ts(c(tail(lnserie,1),pred$pred),start = ultim+c(1,0),freq = 12) #starts Dec 2019!
se<-ts(c(0,pred$se),start = ultim+c(1,0),freq = 12)
#Intervals
tl1<-ts(exp(pr-1.96*se),start = ultim+c(1,0),freq = 12)
tu1<-ts(exp(pr+1.96*se),start = ultim+c(1,0),freq = 12)
pr1<-ts(exp(pr),start = ultim+c(1,0),freq = 12)
ts.plot(serie,tl1,tu1,pr1,lty = c(1,2,2,1),col = c(1,4,4,2),xlim = c(ultim[1]-2,ultim[1]+3),type = "o",main = "Model ARIMA(2,1,0)(0,1,1)_12")
abline(v = (ultim[1]-2):(ultim[1]+3),lty = 3,col = 4)
(previs1 = window(cbind(tl1,pr1,tu1),start = ultim+c(1,0)))
resumen1<-validation(model)
resumen1[16,1] = mod.EQM1
resumen1[17,1] = mod.EAM1
resumen1[18,1] = mod.ML1
cat("mod2B")
#Fit the model to the subset series (without 2019 data): lnserie2
(mod2B2 = arima(lnserie2, order = c(2,1,0),seasonal = list(order = c(1,1,0),period = 12)))
model = mod2B2
##### Use subset series lnserie2 to predict 2019 data
pred = predict(mod2B2,n.ahead = 12)                              #outputs point predictions and corresponding standard errors:for year 2019
se<-ts(c(0,pred$se),start = ultim,freq = 12)                   #Standard errors for point predictions
pr<-ts(c(tail(lnserie2,1),pred$pred),start = ultim,freq = 12)  #point predictions
tl<-ts(exp(pr-1.96*se),start = ultim,freq = 12)
tu<-ts(exp(pr+1.96*se),start = ultim,freq = 12)
pr<-ts(exp(pr),start = ultim,freq = 12)             #pr
(mod.EQM1 = sqrt(sum(((obs-pr)/obs)^2)/12))   # Error  =  obs - pred
(mod.EAM1 = sum(abs(obs-pr)/obs)/12)
(mod.ML1 = sum(tu-tl)/12)
model = mod2B
resumen2<-validation(model)
colnames(resumen2)<-c("mod2B")
resumen2[16,1] = mod.EQM1
resumen2[17,1] = mod.EAM1
resumen2[18,1] = mod.ML1
cat("mod3B")
#Fit the model to the subset series (without 2019 data): lnserie2
(mod3B2 = arima(lnserie2, order = c(0,1,1),seasonal = list(order = c(0,1,1),period = 12)))
model = mod3B2
##### Use subset series lnserie2 to predict 2019 data
pred = predict(mod3B2,n.ahead = 12)                              #outputs point predictions and corresponding standard errors:for year 2019
se<-ts(c(0,pred$se),start = ultim,freq = 12)                   #Standard errors for point predictions
pr<-ts(c(tail(lnserie2,1),pred$pred),start = ultim,freq = 12)  #point predictions
tl<-ts(exp(pr-1.96*se),start = ultim,freq = 12)
tu<-ts(exp(pr+1.96*se),start = ultim,freq = 12)
pr<-ts(exp(pr),start = ultim,freq = 12)             #pr
(mod.EQM1 = sqrt(sum(((obs-pr)/obs)^2)/12))   # Error  =  obs - pred
(mod.EAM1 = sum(abs(obs-pr)/obs)/12)
(mod.ML1 = sum(tu-tl)/12)
model = mod3B
resumen3<-validation(model)
colnames(resumen3)<-c("mod3B")
resumen3[16,1] = mod.EQM1
resumen3[17,1] = mod.EAM1
resumen3[18,1] = mod.ML1
cat("mod4B")
#Fit the model to the subset series (without 2019 data): lnserie2
(mod4B2 = arima(lnserie2, order = c(0,1,1),seasonal = list(order = c(1,1,0),period = 12)))
model = mod4B2
##### Use subset series lnserie2 to predict 2019 data
pred = predict(mod4B2,n.ahead = 12)                              #outputs point predictions and corresponding standard errors:for year 2019
se<-ts(c(0,pred$se),start = ultim,freq = 12)                   #Standard errors for point predictions
pr<-ts(c(tail(lnserie2,1),pred$pred),start = ultim,freq = 12)  #point predictions
tl<-ts(exp(pr-1.96*se),start = ultim,freq = 12)
tu<-ts(exp(pr+1.96*se),start = ultim,freq = 12)
pr<-ts(exp(pr),start = ultim,freq = 12)             #pr
(mod.EQM1 = sqrt(sum(((obs-pr)/obs)^2)/12))   # Error  =  obs - pred
(mod.EAM1 = sum(abs(obs-pr)/obs)/12)
(mod.ML1 = sum(tu-tl)/12)
model = mod4B
resumen4<-validation(model)
colnames(resumen4)<-c("mod4B")
resumen4[16,1] = mod.EQM1
resumen4[17,1] = mod.EAM1
resumen4[18,1] = mod.ML1
tablef<-cbind.data.frame(resumen1,resumen2,resumen3,resumen4)
stargazer(tablef, summary = FALSE, type = "html")
stargazer(tablef, summary = FALSE, type = "pdf")
stargazer(tablef, summary = FALSE, type = "text")
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
serie = window(ts(read.table("Datos/datos.txt", header = F)/1000, start = 2009, freq = 12), start = 2009)
getwd()
setwd("E:/QUART/ANÀLISI DE SERIES TEMPORALS/Pràctica 2")
serie = window(ts(read.table("Datos/datos.txt", header = F)/1000, start = 2009, freq = 12), start = 2009)
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
serie = window(ts(read.table("Datos/datos.txt", header = F)/1000, start = 2009, freq = 12), start = 2009)
serie = window(ts(read.table("E:/QUART/ANÀLISI DE SERIES TEMPORALS/Pràctica 2/datos.txt", header = F)/1000, start = 2009, freq = 12), start = 2009)
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
serie = window(ts(read.table("datos.txt", header = F)/1000, start = 2009, freq = 12), start = 2009)
getwd()
serie = window(ts(read.table("datos.txt", header = F)/1000, start = 2009, freq = 12), start = 2009)
plot(serie, main = "Ocupacion en alojamientos de turismo rural en España")
abline(v = 2009:2019, col = 4, lty = 3)
par(mfrow=c(1,2))
m = apply(matrix(serie,ncol=12),2,mean)
v = apply(matrix(serie,ncol=12),2,var)
plot(v~m,main="Mean-Variance plot")
boxplot(serie~floor(time(serie)))
par(mfrow=c(1,2))
m = apply(matrix(serie,ncol=12),2,mean)
v = apply(matrix(serie,ncol=12),2,var)
plot(v~m,main="Mean-Variance plot")
boxplot(serie~floor(time(serie)))
lnserie=log(serie)
plot(lnserie,type="o")
monthplot(lnserie)
monthplot(d12lnserie)
d12lnserie<-diff(lnserie,lag=12)
monthplot(d12lnserie)
plot(d12lnserie,main="d12lnserie")
abline(h=0)
abline(h=mean(d12lnserie), col=2)
d1d12lnserie <- diff(d12lnserie)
plot(d1d12lnserie,main="d1d12lnserie")
abline(h=0)
abline(h=mean(d1d12lnserie), col=2)
v1 <- var(lnserie)
cat("La serie en escala logarítmica tiene una varianza de", v1, "\n")
v2 <- var(d12lnserie)
cat("La serie en escala logarítmica y con una diferenciación estacional tiene una varianza de", v2, "\n")
v3 <- var(d1d12lnserie)
cat("La serie en escala logarítmica y con una diferenciación estacional y otra regular tiene una varianza de", v3, "\n")
v1 <- var(lnserie)
cat("La serie en escala logarítmica tiene una varianza de", v1, "\n")
v2 <- var(d12lnserie)
cat("La serie en escala logarítmica y con una diferenciación estacional tiene una varianza de", v2, "\n")
v3 <- var(d1d12lnserie)
cat("La serie en escala logarítmica y con una diferenciación estacional y otra regular tiene una varianza de", v3, "\n")
table(Modelo = c("lnserie", "d12lnserie", "d1d12lnserie"), Varianza = c(v1, v2, v3))
v1 <- var(lnserie)
cat("La serie en escala logarítmica tiene una varianza de", v1, "\n")
v2 <- var(d12lnserie)
cat("La serie en escala logarítmica y con una diferenciación estacional tiene una varianza de", v2, "\n")
v3 <- var(d1d12lnserie)
cat("La serie en escala logarítmica y con una diferenciación estacional y otra regular tiene una varianza de", v3, "\n")
df = data.frame(Modelo = c("lnserie", "d12lnserie", "d1d12lnserie"), Varianza = c(v1, v2, v3))
df
table(data.frame(Modelo = c("lnserie", "d12lnserie", "d1d12lnserie"), Varianza = c(v1, v2, v3)))
kable(data.frame(Modelo = c("lnserie", "d12lnserie", "d1d12lnserie"), Varianza = c(v1, v2, v3)))
library(knitr)
kable(data.frame(Modelo = c("lnserie", "d12lnserie", "d1d12lnserie"), Varianza = c(v1, v2, v3)))
par(mfrow=c(1,2))
acf(d1d12lnserie,ylim=c(-1,1),lag.max=60,col=c(2,rep(1,11)),lwd=2)
pacf(d1d12lnserie,ylim=c(-1,1),lag.max=60,col=c(2,rep(1,11)),lwd=2)
par(mfrow=c(1,2))
acf(d1d12lnserie,ylim=c(-1,1),lag.max=60,col=c(2,rep(1,11)),lwd=2)
pacf(d1d12lnserie,ylim=c(-1,1),lag.max=60,col=c(2,rep(1,11)),lwd=2)
par(mfrow=c(1,2))
acf(d1d12lnserie,ylim=c(-1,1),lag.max=60,col=c(2,rep(1,11)),lwd=2)
pacf(d1d12lnserie,ylim=c(-1,1),lag.max=60,col=c(2,rep(1,11)),lwd=2)
v1 <- var(lnserie)
v2 <- var(d12lnserie)
v3 <- var(d1d12lnserie)
library(knitr)
kable(data.frame(Varianza = c(v1, v2, v3), Modelo = c("lnserie", "d12lnserie", "d1d12lnserie")))
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
serie = window(ts(read.table("datos.txt", header = F)/1000, start = 2009, freq = 12), start = 2009)
plot(serie, main = "Ocupacion en alojamientos de turismo rural en España")
abline(v = 2009:2019, col = 4, lty = 3)
par(mfrow=c(1,2))
m = apply(matrix(serie,ncol=12),2,mean)
v = apply(matrix(serie,ncol=12),2,var)
plot(v~m,main="Mean-Variance plot")
boxplot(serie~floor(time(serie)), main = "Boxplot")
lnserie=log(serie)
plot(lnserie,type="o")
monthplot(lnserie)
d12lnserie<-diff(lnserie,lag=12)
monthplot(d12lnserie)
plot(d12lnserie,main="d12lnserie")
abline(h=0)
abline(h=mean(d12lnserie), col=2)
d1d12lnserie <- diff(d12lnserie)
plot(d1d12lnserie,main="d1d12lnserie")
abline(h=0)
abline(h=mean(d1d12lnserie), col=2)
v1 <- var(lnserie)
v2 <- var(d12lnserie)
v3 <- var(d1d12lnserie)
par(mfrow=c(1,2))
acf(d1d12lnserie,ylim=c(-1,1),lag.max=60,col=c(2,rep(1,11)),lwd=2)
pacf(d1d12lnserie,ylim=c(-1,1),lag.max=60,col=c(2,rep(1,11)),lwd=2)
mod1A = arima(d1d12lnserie, order = c(0,0,1), seasonal = list(order = c(0,0,1), period=12))
#cat("Modelo 1a \n T-ratios:",round(mod1A$coef/sqrt(diag(mod1A$var.coef)),2))
mod1B = arima(lnserie, order = c(0,1,1), seasonal = list(order = c(0,1,1), period=12))
#cat("Modelo 1b \nT-ratios:",round(mod1B$coef/sqrt(diag(mod1B$var.coef)),2))
mod2A = arima(d1d12lnserie, order = c(3,0,0), seasonal = list(order = c(0,0,1), period=12))
#cat("Modelo 2a \nT-ratios:",round(mod2A$coef/sqrt(diag(mod2A$var.coef)),2))
mod2B = arima(lnserie, order = c(3,1,0), seasonal = list(order = c(0,1,1), period=12))
#cat("Modelo 2b \nT-ratios:",round(mod2B$coef/sqrt(diag(mod2B$var.coef)),2))
mod3A = arima(d1d12lnserie, order = c(1,0,1), seasonal = list(order = c(0,0,1), period=12))
#cat("Modelo 3a \nT-ratios:",round(mod3A$coef/sqrt(diag(mod3A$var.coef)),2))
mod3B = arima(lnserie, order = c(1,1,1), seasonal = list(order = c(0,1,1), period=12))
#cat("Modelo 3b \nT-ratios:",round(mod3B$coef/sqrt(diag(mod3B$var.coef)),2))
#install.packages("stargazer")
library("stargazer")
stargazer(mod1A, mod2A, mod3A, mod1B, mod2B, mod3B, title="Results", type="text", notes.append = FALSE, report = "vct",
notes = c("t = T-statistic value = coeff/SE(coeff)"), digits = 3,
column.labels = c("1A","2A","3A","1B","2B","3B"))
validation_grafic <- function(model, dades){
s = frequency(get(model$series))
resid = model$residuals
par(mfrow = c(2, 2), mar = c(3, 3, 3, 3))
#Residuals plot
plot(resid, main = "Residuals")
abline(h = 0)
abline(h = c(-3*sd(resid, na.rm = T), 3*sd(resid, na.rm = T)), lty = 3, col = 4)
#Square Root of absolute values of residuals (Homocedasticity)
scatter.smooth(sqrt(abs(resid)), main = "Square Root of Absolute residuals",
lpars = list(col = 2))
#Normal plot of residuals
qqnorm(resid)
qqline(resid, col = 2, lwd = 2)
#Histogram of residuals with normal curve
hist(resid, breaks = 20, freq = F)
curve(dnorm(x, mean = mean(resid, na.rm = T), sd = sd(resid, na.rm = T)), col = 2, add = T)
}
mod1A = arima(d1d12lnserie, order = c(0,0,1), seasonal = list(order = c(0,0,1), period=12))
(mod1A = arima(d1d12lnserie, order = c(0,0,1), seasonal = list(order = c(0,0,1), period=12)))
cat("Modelo 1a \n T-ratios:",round(mod1A$coef/sqrt(diag(mod1A$var.coef)),2))
(mod1B = arima(lnserie, order = c(0,1,1), seasonal = list(order = c(0,1,1), period=12)))
cat("Modelo 1b \nT-ratios:",round(mod1B$coef/sqrt(diag(mod1B$var.coef)),2))
mod2A = arima(d1d12lnserie, order = c(3,0,0), seasonal = list(order = c(0,0,1), period=12))
(mod2A = arima(d1d12lnserie, order = c(3,0,0), seasonal = list(order = c(0,0,1), period=12)))
cat("Modelo 2a \nT-ratios:",round(mod2A$coef/sqrt(diag(mod2A$var.coef)),2))
(mod2B = arima(lnserie, order = c(3,1,0), seasonal = list(order = c(0,1,1), period=12)))
cat("Modelo 2b \nT-ratios:",round(mod2B$coef/sqrt(diag(mod2B$var.coef)),2))
cat("Modelo 2b \nT-ratios:",round(mod2B$coef/sqrt(diag(mod2B$var.coef)),2))
(mod1B2 = arima(lnserie,  order = c(3, 1, 0), seasonal = list(order = c(0, 1, 1), period = 12),  fixed = c(NA, NA, 0, NA)))
(mod2B = arima(lnserie, order = c(3,1,0), seasonal = list(order = c(0,1,1), period=12)))
(mod3A = arima(d1d12lnserie, order = c(1,0,1), seasonal = list(order = c(0,0,1), period=12)))
cat("Modelo 3a \nT-ratios:",round(mod3A$coef/sqrt(diag(mod3A$var.coef)),2))
cat("Modelo 3b \nT-ratios:",round(mod3B$coef/sqrt(diag(mod3B$var.coef)),2))
mod3B = arima(lnserie, order = c(1,1,1), seasonal = list(order = c(0,1,1), period=12))
mod1A, mod2A, mod3A, mod1B, mod2B, mod3B, title="Results", type="text", notes.append = FALSE, report = "vct",
#install.packages("stargazer")
library("stargazer")
stargazer(mod1A, mod2A, mod3A, title="Results", type="text", notes.append = FALSE, report = "vct",
notes = c("t = T-statistic value = coeff/SE(coeff)"), digits = 3,
column.labels = c("1A","2A","3A"))
#install.packages("stargazer")
library("stargazer")
tabla1 <- stargazer(mod1A, mod2A, mod3A, title="Results", type="text", notes.append = FALSE, report = "vct",
notes = c("t = T-statistic value = coeff/SE(coeff)"), digits = 3,
column.labels = c("1A","2A","3A"))
kable(tabla1)
#install.packages("stargazer")
library("stargazer")
stargazer(mod1A, mod2A, mod3A, title="Results", type="text", notes.append = FALSE, report = "vct",
notes = c("t = T-statistic value = coeff/SE(coeff)"), digits = 3,
column.labels = c("1A","2A","3A"))
?stargazer
#install.packages("stargazer")
library("stargazer")
stargazer(mod1A, mod2A, mod3A, title="Results", type="html", notes.append = FALSE, report = "vtc",
notes = c("t = T-statistic value = coeff/SE(coeff)"), digits = 3,  column.labels = c("1A","2A","3A"))
df <- data.frame(Models = c(mod1A, mod2A, mod3A))
model = mod2B
validation_grafic(model)
validation_test_homoce(model)
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
serie = window(ts(read.table("datos.txt", header = F)/1000, start = 2009, freq = 12), start = 2009)
plot(serie, main = "Ocupacion en alojamientos de turismo rural en España")
abline(v = 2009:2019, col = 4, lty = 3)
par(mfrow=c(1,2))
m = apply(matrix(serie,ncol=12),2,mean)
v = apply(matrix(serie,ncol=12),2,var)
plot(v~m,main="Mean-Variance plot")
boxplot(serie~floor(time(serie)), main = "Boxplot")
lnserie=log(serie)
plot(lnserie,type="o")
monthplot(lnserie)
d12lnserie<-diff(lnserie,lag=12)
monthplot(d12lnserie)
plot(d12lnserie,main="d12lnserie")
abline(h=0)
abline(h=mean(d12lnserie), col=2)
d1d12lnserie <- diff(d12lnserie)
plot(d1d12lnserie,main="d1d12lnserie")
abline(h=0)
abline(h=mean(d1d12lnserie), col=2)
v1 <- var(lnserie)
v2 <- var(d12lnserie)
v3 <- var(d1d12lnserie)
par(mfrow=c(1,2))
acf(d1d12lnserie,ylim=c(-1,1),lag.max=60,col=c(2,rep(1,11)),lwd=2)
pacf(d1d12lnserie,ylim=c(-1,1),lag.max=60,col=c(2,rep(1,11)),lwd=2)
mod1A = arima(d1d12lnserie, order = c(0,0,1), seasonal = list(order = c(0,0,1), period=12))
cat("Modelo 1a \n T-ratios:",round(mod1A$coef/sqrt(diag(mod1A$var.coef)),2))
mod1B = arima(lnserie, order = c(0,1,1), seasonal = list(order = c(0,1,1), period=12))
cat("Modelo 1b \nT-ratios:",round(mod1B$coef/sqrt(diag(mod1B$var.coef)),2))
mod2A = arima(d1d12lnserie, order = c(3,0,0), seasonal = list(order = c(0,0,1), period=12))
cat("Modelo 2a \nT-ratios:",round(mod2A$coef/sqrt(diag(mod2A$var.coef)),2))
mod2B = arima(lnserie, order = c(3,1,0), seasonal = list(order = c(0,1,1), period=12))
cat("Modelo 2b \nT-ratios:",round(mod2B$coef/sqrt(diag(mod2B$var.coef)),2))
mod1B2 = arima(lnserie,  order = c(3, 1, 0), seasonal = list(order = c(0, 1, 1), period = 12),  fixed = c(NA, NA, 0, NA))
mod3A = arima(d1d12lnserie, order = c(1,0,1), seasonal = list(order = c(0,0,1), period=12))
cat("Modelo 3a \nT-ratios:",round(mod3A$coef/sqrt(diag(mod3A$var.coef)),2))
mod3B = arima(lnserie, order = c(1,1,1), seasonal = list(order = c(0,1,1), period=12))
cat("Modelo 3b \nT-ratios:",round(mod3B$coef/sqrt(diag(mod3B$var.coef)),2))
#install.packages("stargazer")
library("stargazer")
stargazer(mod1A, mod2A, mod3A, title="Results", type="text", notes.append = FALSE, report = "vtc",
notes = c("t = T-statistic value = coeff/SE(coeff)"), digits = 3,  column.labels = c("1A","2A","3A"))
#install.packages("stargazer")
library("stargazer")
stargazer(mod1B, mod2B, mod3B, title="Results", type="text", notes.append = FALSE, report = "vct",
notes = c("t = T-statistic value = coeff/SE(coeff)"), digits = 3,
column.labels = c("1B","2B","3B"))
validation_grafic <- function(model, dades){
s = frequency(get(model$series))
resid = model$residuals
par(mfrow = c(2, 2), mar = c(3, 3, 3, 3))
#Residuals plot
plot(resid, main = "Residuals")
abline(h = 0)
abline(h = c(-3*sd(resid, na.rm = T), 3*sd(resid, na.rm = T)), lty = 3, col = 4)
#Square Root of absolute values of residuals (Homocedasticity)
scatter.smooth(sqrt(abs(resid)), main = "Square Root of Absolute residuals",
lpars = list(col = 2))
#Normal plot of residuals
qqnorm(resid)
qqline(resid, col = 2, lwd = 2)
#Histogram of residuals with normal curve
hist(resid, breaks = 20, freq = F)
curve(dnorm(x, mean = mean(resid, na.rm = T), sd = sd(resid, na.rm = T)), col = 2, add = T)
}
validation_test_homoce <- function(model, dades){
suppressMessages(require(lmtest, quietly = TRUE, warn.conflicts = FALSE))
##Breusch-Pagan test (vs. order)
obs = get(model$series)
print(bptest(resid(model)~I(1:length(resid(model)))))
##Breusch-Pagan test (vs. predictions)
obs = get(model$series)
print(bptest(resid(model)~I(obs-resid(model))))
}
validation_test_normal <- function(model, dades){
##Shapiro-Wilks Normality test
print(shapiro.test(resid(model)))
suppressMessages(require(nortest, quietly = TRUE, warn.conflicts = FALSE))
##Anderson-Darling test
print(ad.test(resid(model)))
suppressMessages(require(tseries, quietly = TRUE, warn.conflicts = FALSE))
##Jarque-Bera test
print(jarque.bera.test(na.omit(c(resid(model)))))
}
validation_test_indepen <- function(model, dades){
s = frequency(get(model$series))
resid = model$residuals
##Durbin-Watson test
print(dwtest(resid(model)~I(1:length(resid(model)))))
##Ljung-Box test
cat("\nLjung-Box test\n")
print(t(apply(matrix(c(1:4, (1:4)*s)), 1, function(el) {
te = Box.test(resid(model), type = "Ljung-Box", lag = el)
c(lag = (te$parameter), statistic = te$statistic[[1]], p.value = te$p.value)})))
}
validation_acf_pacf <- function(model, dades){
s = frequency(get(model$series))
resid = model$residuals
#ACF & PACF of residuals
par(mfrow=c(1,2))
acf(resid,ylim=c(-1,1),lag.max=60,col=c(2,rep(1,s-1)),lwd=1)
pacf(resid,ylim=c(-1,1),lag.max=60,col=c(rep(1,s-1),2),lwd=1)
par(mfrow=c(1,1))
#ACF & PACF of square residuals
par(mfrow=c(1,2))
acf(resid^2,ylim=c(-1,1),lag.max=60,col=c(2,rep(1,s-1)),lwd=1)
pacf(resid^2,ylim=c(-1,1),lag.max=60,col=c(rep(1,s-1),2),lwd=1)
par(mfrow=c(1,1))
}
validation_pesos <- function(model, dades){
#Model expressed as an MA infinity (psi-weights)
psis = ARMAtoMA(ar = model$model$phi, ma = model$model$theta, lag.max = 36)
names(psis) = paste("psi", 1:36)
cat("\nPsi-weights (MA(inf))\n")
print(psis[1:20])
#Model expressed as an AR infinity (pi-weights)
pis = -ARMAtoMA(ar = -model$model$theta, ma = -model$model$phi, lag.max = 36)
names(pis) = paste("pi", 1:36)
cat("\nPi-weights (AR(inf))\n")
print(pis[1:20])
}
model = mod2B
validation_grafic(model)
validation_test_homoce(model)
validation_test_normal(model)
validation_test_indepen(model)
validation_test_indepen(model)
validation_acf_pacf(model)
validation_acf_pacf(model)
validation_pesos(model)
